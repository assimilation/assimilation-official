#!/bin/sh -eu
# vim: smartindent tabstop=4 shiftwidth=4 expandtab number colorcolumn=80
#
#
# sudoers: Discovery module for the /etc/sudoers configuration file(s)
#          Sudoer configuration is a bit obscure to say the least...
#
# This file is part of the Assimilation Project.
#
# Author: Alan Robertson <alanr@unix.sh>
# Copyright (C) 2015 - Assimilation Systems Limited
#
# Free support is available from the Assimilation Project community
#   - http://assimproj.org
# Paid support is available from Assimilation Systems Limited
#   - http://assimilationsystems.com
#
# The Assimilation software is free software: you can redistribute it and/or
# modify # it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# The Assimilation software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with the Assimilation Project software.
# If not, see http://www.gnu.org/licenses/
#
set -e
: ${SUDOERS_FILE:=/etc/sudoers}
mktmpdir() {
    # Some OSes don't include the mktemp command...
    mktemp -d 
}
TMPDIR=$(mktmpdir)
trap 'rm -fr "${TMPDIR}"' 0
EXPANDEDFILE="${TMPDIR}/totalfile"
DEFAULTS="${TMPDIR}/defaults"
USER_ALIAS="${TMPDIR}/user_alias"
RUNAS_ALIAS="${TMPDIR}/runas_alias"
CMND_ALIAS="${TMPDIR}/cmnd_alias"
HOST_ALIAS="${TMPDIR}/host_alias"
RULES="${TMPDIR}/Rules"

nl='
'

#	Read a single line - allow for "line" to be missing
firstline() {
	head -n 1
}

#   Read a line with \ as continuation charcter at the end of the line
read_cont_line() {
    initline=''
    while
        true
    do
        read a_line || return 1
        case "$a_line" in
            '#include'*);;
            '#'*|'')   continue;;
        esac
        initline="${initline}${a_line}"
        case "${a_line}" in
            '\\')   continue;;
        esac
        echo "${initline}"
        return 0
    done
}
flatten_sudoer_files() {
    (
    # This subshell is a POSIX compliant way of getting local variables
    trap '' 0
    #echo "@startinclude $1"
    while
        cont_line=$(read_cont_line)
    do
        case $cont_line in
            '#includedir'*)
                dir=$(echo "$cont_line" | sed --e 's%#includedir *%%' -e 's% *$%%')
                for file in $(echo $dir/*)
                do
                    flatten_sudo_files "$file"
                done
                ;;
            '#include'*)
                file=$(echo "$cont_line" | sed --e 's%#include *%%' -e 's *$%%')
                flatten_sudo_files "$file"
                ;;
            *)  echo "$cont_line"
                ;;
        esac
    done
    #echo "@endinclude $1"
    ) < $1
}
#
#   Split our sudoers rules into one file for each kind of info
#
split_sudoers() {
    while
        read line
    do
        case $line in
            Cmnd_Alias*)    echo "$line" >> ${CMND_ALIAS};;
            Defaults*)      echo "$line" >> ${DEFAULTS};;
            Host_Alias*)    echo "$line" >> ${HOST_ALIAS};;
            Runas_Alias*)   echo "$line" >> ${RUNAS_ALIAS};;
            User_Alias*)    echo "$line" >> ${USER_ALIAS};;
            *)              echo "$line" >> ${RULES};;
        esac
    done < "$1"
}
#
#   Process an alias line, they're overly complicated...
#
process_aliases() {
    if
        [ ! -f "$2" ]
    then
        return 1
    fi
    printf '"%s": {\n       ' "$1"
    aliascomma=''
    while
        read keyword nameandstuff
    do
        process_alias_names "$aliascomma" $nameandstuff
        aliascomma=",${nl}       "
    done < "$2"
    printf '\n     }\n'
}
#
#   Process the stuff from an alias line
#
process_alias_names() {
    outercomma=$1
    shift
    set -- $*
    state=init
    innercomma=''
    value=''
    space="       "
    shasum=''
    for arg
    do
        case $state in
            init)   name="$arg"
                    state='other'
                    continue
                    ;;
        esac
        case "$arg" in
            :) printf '%s"%s": [%s]' "$outercomma" "$name" "$value"
                outercomma=",${nl}${space}"
                value=''
                innercomma=''
                state=init
                ;;
            ,)  ;;
            =)  ;;
            sha[0-9][0-9][0-9]:*)
                shasum="$arg"
                continue;;
            *)  arg=$(echo "$arg" | sed -e 's%,$%%')
                if
                    [ "X${shasum}" != X ]
                then
                    arg=$(printf '{"sum": "%s", "file": "%s"}' "$shasum" "$arg")
                    shasum=''
                    value=$(printf '%s%s%s' "$value" "$innercomma" "$arg")
                else
                    value=$(printf '%s%s"%s"' "$value" "$innercomma" "$arg")
                fi
                innercomma=', '
                ;;
        esac
    done
    if
        [ "X${arg}" != X -a "X${value}" != X ]
    then
        printf '%s"%s": [%s]' "$outercomma" "$name" "$value"
    fi
}

#   Process the defaults section...
process_defaults() {
    if
        [ ! -f "$1" ]
    then
        return 1
    fi
    prevsect=''
    space='      '
    printf '"Defaults": {\n%s' "$space"
    while
        read default stuff
    do
        if
            [ "${default}" != "${prevsect}" ]
        then
            if
                [ "${prevsect}" != "" ]
            then
                printf '},\n%s' "$space"
            fi
            prevsect="${default}"
            suffix=$(echo "$default" | sed -e 's%Defaults.%%')
            case $default in
                'Defaults')
                    printf '    "ANY": {';;
                'Defaults>'*)
                    printf '    "runas:%s": {' "$suffix";;
                'Defaults:'*)
                    printf '    "user:%s": {' "$suffix";;
                'Defaults@'*)
                    printf '    "system:%s": {' "$suffix";;
                'Defaults!'*)
                    printf '    "command:%s": {' "$suffix";;
            esac
        fi
        process_default_opts ${stuff}
    done < $1
    printf '}\n    }\n'
}
#
#   Process the options given on a Defaults line
#
process_default_opts() {
    set -- $*
    (
        comma=''
        for arg
        do
            arg=$(echo "$arg" | sed 's%,$%%')
            case $arg in
                *=*)    
                    name=$(echo "$arg" | sed 's%=.*%%')
                    value=$(echo "$arg" | sed 's%.*=%%')
                    printf '%s"%s": "%s"' "$comma" "$name" "$value"
                    ;;
                !*) name=$(echo "$arg" | sed 's%^!%%')
                    printf '%s"%s": false' "$comma" "$name"
                    ;;
                ?*) printf '%s"%s": true' "$comma" "$arg"
                    ;;
            esac
            comma=', '
        done
    )
}

#   Process the parenthesized runas-spec
process_runas_spec() {
    #printf '\nPROCESS RUNAS: %s\n' "$*"
    # strip the parentheses.
    spec=$(echo $* | sed -e 's%^ *( *%%' -e 's% *) *$%%')
    case $spec in
        *:*)    
            userspec=$(echo $spec  | sed -e 's% *:.*%%')
            groupspec=$(echo $spec | sed -e 's%.*: *%%')
            ;;
        *)  userspec=$spec
            groupspec=''
            ;;
    esac
    # Now what we have here are potentially two runas-lists
    # each is a bunch of words separated by commas and optionally-prefixed
    # by ! characters (meaning not)
    userjson=$(process_runas_list  $userspec)
    groupjson=$(process_runas_list $groupspec)
    printf '{"users":%s, "groups":%s}' "$userjson" "$groupjson"
}
#
#   Get rid of a stupid option that lets you put more than one
#   not symbol (!) in front of an option. Even numbers mean nothing
#   and odd numbers are the same as one...
#
fix_banglist() {
    list="$*"
    while
        case $list in
            *!!*)   true;;
            *)      false;;
        esac
    do
        list=$(echo "$list" | sed -e 's%!!!!%%' -e 's%!!%%')
    done
    echo "$list"
}

process_runas_list() {
    # Eliminate commas, and spaces after ! symbols
    runaslist=$(echo $* | sed -e 's%,% %' -e 's%  % %' -e 's%! *%!%')
    runaslist=$(fix_banglist "$runaslist")
    set -- $runaslist
    ourcomma=''
    printf '['
    for word
    do
        case $word in
            !*) word=$(sed 's%!%%')
                printf '%s"%s"' "$ourcomma" "$word"
                ;;
            *)  printf '%s"%s"' "$ourcomma" "$word"
                ;;
        esac
        ourcomma=', '
    done
    printf ']'
}
#
#   Process the rules that say who can run what...
#     User_Spec ::= User_List Host_List '=' Cmnd_Spec_List \
#                   (':' Host_List '=' Cmnd_Spec_List)*
#
#     Cmnd_Spec_List ::= Cmnd_Spec |
#                        Cmnd_Spec ',' Cmnd_Spec_List
#
#     Cmnd_Spec ::= Runas_Spec? SELinux_Spec? Tag_Spec* Cmnd
#
#
#   It's impossible to tell users from hosts...
#   users can be user names, #uids, %group, +netgroup %:non-unix-group
#   %:#non-unix--gid or a user alias
#   Hosts can be host names, IP addresses, network numbers +netgroup, and
#   host aliases.
#   user names can be the *same* as host names
#   netgroups can be any kind of thing
#   host aliases are syntactically the same as user aliases, and in fact
#   are a separate name space, so they can be the same name...
#
#   The only way to separate them is to *NOT* put a , between two items
#   That division is the only way to distinguish between the User_List
#   and the Host_List
#
#

#
# divide the userlist from everything else on a User_Spec Rule
# Output is two lines:
#   First line is the User_List
#   Second line is Host_List (if any) and everything else
divide_up_rule() {
    #echo "DIVIDE UP RULE: $*" >&2
    set -- $(echo $* | sed -e 's%,% , %g' -e 's%(% ( %g' -e 's%)% ) %g')
    while
        [ $# -ge 2 ]
    do
        printf '%s ' "${1}"
        shift
        case $1 in
            ,)      shift;;
            '(')    printf '( '
                    shift
                    break
                    ;;
            *)      break
                    ;;
        esac
    done
    printf '\n'
    for arg
    do
        printf '%s ' "$arg"
    done
    printf '\n'
}

process_rules() {
    prefix=$(echo "$*" | sed 's% *=.*%%')
    suffix=$(echo "$*" | sed 's%.*= *%%')
    # This prefix can be a set of users followed by hosts
    # ":" separates our hostlist = cmd_spec_list
    suffix=$(echo "$suffix" | tr ',' '\012')
    cmdcomma=''
    printf '"rules": [\n         '
    echo "$suffix" |
    while
      read cmd_spec
    do
        rulelist=$(divide_up_rule $cmd_spec)
        user_list=$(echo "$rulelist" | firstline)
        everything_else=$(echo "$rulelist" | tail -1)
        usercomma=''
        printf '%s{"users": [' "$cmdcomma"
        for user in $user_list
        do
            printf '%s"%s"' "$usercomma" "$user"
            usercomma=', '
        done
        printf '], "rulelist": ['
        # This uses a GNU Sed extension (\o012 for newline)
        # Sorry!
        echo "$everything_else" | sed 's% : %\o012%g' |
        (rulecomma=''
        while
            read a_rule
        do
            printf '%s{' "${rulecomma}"
            format_host_and_commands "$a_rule"
            rulecomma=", "
        done)
        printf '}]}'
        cmdcomma=",${nl}         "
    done < $1
    printf '\n    ]'
}

#
#   This is  the Host_List '=' Cmnd_Spec_List 
#     Cmnd_Spec ::= Runas_Spec? SELinux_Spec? Tag_Spec* Cmnd
#
#   Cmnd_Spec_List is a comma-separated list of Cmnd_Specs
#   "hosts": ["host", "..."]
#   "runas": {"users":[...], "groups": [...]}
#   "cmds": [{"runas":, "selinux":{}, "tags:{"tag":true}, "cmd": "command"}]

format_host_and_commands() {
    hostlist=''
    set -- $*
    #printf "HOSTS AND COMMANDS: %s" "$*" >&2
    printf '"hosts": ['
    ourcomma=''
    # Create the host list...
    while
        [ $# -ge 1 ]
    do
        arg=$1
        shift
        case $arg in
            ',')    continue;;
            '=')    break;;
            *)      printf '%s"%s"' "$ourcomma" "$arg"
                    ourcomma=', ';;
        esac
    done
    printf '], '
    while
        [ $# -ge 1 ]
    do
        arg=$1
        shift
        case $arg in
            '(') 
                #printf "GOT ( in: $*\n" >&2
                runas=''
                while
                    [ $# -gt 0 -a "$1" != ')' ]
                do
                    runas="$runas $1"
                    shift
                done
                shift # for the ')'
                printf '"runas": %s' "$(process_runas_spec $runas)"
                printf ', '
                ;;
        ROLE=*) role=$(echo "$arg" | sed 's%.*=%%')
                printf '"SELinuxRole": "%s", ' "$role"
                ;;
        TYPE=*) setype=$(echo "$arg" | sed 's%.*=%%')
                printf '"SELinuxType": "%s", ' "$setype"
                ;;
        ?*:)    # Tag
                tag=$(echo "$arg" | sed 's%:$%%')
                printf '"TAG_%s": true, ' "$tag"
                ;;
        *)      printf '"command": "%s"' "$arg"

        esac
    done
}



sudoer_info() {
    flatten_sudoer_files ${SUDOERS_FILE} > ${EXPANDEDFILE}
    split_sudoers "${EXPANDEDFILE}"
    sort -s -o "${DEFAULTS}" "${DEFAULTS}" 
#cat $EXPANDEDFILE
    commands="process_aliases HostAliases   ${HOST_ALIAS}
    process_aliases CommandAliases          ${CMND_ALIAS}
    process_aliases UserAliases             ${USER_ALIAS}
    process_aliases RunasAliases            ${RUNAS_ALIAS}
    process_defaults                        ${DEFAULTS}
    process_rules ${RULES}"
    spaces='    '
    outercomma=$spaces
    echo "$commands" |
    while
        read cmdline
    do
        if
            OUT=$($cmdline)
        then
            printf '%s%s' "$outercomma" "$OUT"
            outercomma=",${nl}${spaces}"
        fi
    done
}

discover() {
    cat <<-!
	{
	  "discovertype": "sudoers",
	  "description": "${SUDOERS_FILE} configuration",
	  "host": "$(uname -n)",
	  "source": "$0",
	  "data": {
	!
    if
        [  -f ${SUDOERS_FILE}  -a -r ${SUDOERS_FILE} ]
    then
        sudoer_info
    else
        printf '    "NODATA": "ERROR: Cannot read %s"'  "$SUDOERS_FILE"
    fi       
    printf '\n  }\n}\n'
}

discover
